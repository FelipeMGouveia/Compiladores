/*
 * generated by Xtext
 */
package br.poli.ecomp.compiladores.generator

import br.poli.ecomp.compiladores.notC.Block
import br.poli.ecomp.compiladores.notC.Code
import br.poli.ecomp.compiladores.notC.Command
import br.poli.ecomp.compiladores.notC.Declaration
import br.poli.ecomp.compiladores.notC.Expression
import br.poli.ecomp.compiladores.notC.FuncParam
import br.poli.ecomp.compiladores.notC.Function
import br.poli.ecomp.compiladores.notC.IDDeclaration
import br.poli.ecomp.compiladores.notC.IfCommand
import br.poli.ecomp.compiladores.notC.RDeclaration
import br.poli.ecomp.compiladores.notC.Statement
import br.poli.ecomp.compiladores.notC.Type
import br.poli.ecomp.compiladores.notC.WhileCommand
import java.util.ArrayList
import java.util.HashMap
import java.util.HashSet
import java.util.List
import java.util.Map
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.IFileSystemAccess
import org.eclipse.xtext.generator.IGenerator

import static extension org.eclipse.xtext.EcoreUtil2.*
import br.poli.ecomp.compiladores.notC.KDeclaration

/**
 * Generates code from your model files on save.
 * 
 * see http://www.eclipse.org/Xtext/documentation.html#TutorialCodeGeneration
 */
class NotCGenerator implements IGenerator {
	static class Variable
	{
		public String name;
		public Integer value = null;
	
		new(String n) 
		{
			name = n;
		}
		new(String n, Integer i) 
		{
			name = n;
			value = i;
		}
		
		override boolean equals(Object variable)
		{
			if(variable instanceof Variable)
			{
				return (variable as Variable).name.equals(this.name);
			}
			return false;
		}
		override int hashCode()
		{
			return name.hashCode;
		}
	}
	//Guarda em que parte do código estamos, serve para trabalhar com variáveis
	private Integer currentCodeScope;
	//Variáveis definidas neste escopo
	private Map<Integer, List<Variable>> variablesByScope;
	
	def compileCode(Code code)
	'''«IF variablesByScope.put(currentCodeScope, new ArrayList<Variable>()) == null»«ENDIF»«IF code.declarations != null»«FOR declaration : code.declarations»«declaration.compile»
«ENDFOR»«ENDIF»«IF code.functions != null»«FOR function : code.functions»«function.compile»«ENDFOR»«ENDIF»
	'''
	def dispatch compile(Declaration declaration)
	'''«IF canAddVariable(declaration.value) »«ENDIF»«declaration.type.compile» «declaration.value.compile»;'''
	
	def canAddVariable(RDeclaration declaration) 
	{
		if(currentCodeScope > 0)
		{
			
		}
		
		return true;
	}
	
	def dispatch compile(RDeclaration rDeclaration)
	'''«IF rDeclaration.id != null»«rDeclaration.id.compile»«ENDIF»«IF rDeclaration.left != null»«rDeclaration.left.compile»«ENDIF»«IF rDeclaration.next != null», «rDeclaration.next.compile»«ENDIF»'''
	def dispatch compile(KDeclaration kDeclaration)
	'''«IF kDeclaration.declaration != null»«kDeclaration.declaration.compile»«ENDIF»;'''
	
	def dispatch compile(IDDeclaration idDeclaration)
	'''«IF validateId(idDeclaration) »«ENDIF»«idDeclaration.id»«IF idDeclaration.value != null» = «IF getValue(idDeclaration.id) != null»«getValue(idDeclaration.id)»«ELSE»«idDeclaration.value.compile»«ENDIF»«ENDIF»'''
	
	def getValue(String varName) 
	{
		var variables = variablesByScope.get(currentCodeScope);
		var newVariable = new Variable(varName);
		if(variables.contains(newVariable))
		{
			return variables.get(variables.indexOf(newVariable)).value;
		}
		return null;
	}
	
	def validateId(IDDeclaration idDeclaration) 
	{
		var variables = variablesByScope.get(currentCodeScope);
		var newVariable = new Variable(idDeclaration.id.toString());
		if(variables.contains(newVariable))
		{
			variables.get(variables.indexOf(newVariable)).value = solve(idDeclaration.value);
		}
		else
		{
			variables.add(new Variable(idDeclaration.id.toString(), solve(idDeclaration.value)))	
		}
		return false;
	}
	
	//Integer leftValue;
	//Integer rightValue;
	
//	def Integer solve(Expression expression)
//	{
//		//solve(expression, );
//	}
	
	def Integer solve(Expression expression) 
	{
		var leftValue = new Integer(0);
		var rightValue = new Integer(0);
		if (expression == null)
			return null;
		if(expression.result != null)
		{
			try
			{
				//Se for um inteiro retornamos ele mesmo.
				return Integer.parseInt(expression.result);
			}
			catch(Exception e)
			{
				//Senão, tentamos capturar o valor do mesmo pelo mapa
				for(Variable variable : variablesByScope.get(currentCodeScope))
				{
					//Se a variável existir retorne o seu valor.
					if(variable.name.equals(expression.result))
					{
						return variable.value;
					}
				}
			}
			return null;
		}
		if(expression.value != null)
		{
			return solve(expression.value);
		}
		if(expression.operator != null)
		{
			leftValue = solve(expression.left);
			rightValue = solve(expression.right);
			if(leftValue == null || rightValue == null)
			{
				return null;
			}
			switch(expression.operator)
			{
				case "+":
				{
					return leftValue + rightValue;
				}
				case "-":
				{
					return leftValue - rightValue;
				}
				case "*":
				{
					return leftValue * rightValue;
				}
				case "/":
				{
					return leftValue / rightValue;
				}
				case "^":
				{
					return Math.pow(leftValue.doubleValue, rightValue.doubleValue).intValue;
				}
				default:
				{
					return leftValue;
				}
			}
		}
		else
		{
			return leftValue;	
		}
	}
	
	def Integer solve2(Expression expression, List<Variable> variables) 
	{
		System.out.println("Solve 2");
		var leftValue = new Integer(0);
		var rightValue = new Integer(0);
		if (expression == null)
			return null;
		if(expression.result != null)
		{
			try
			{
				//Se for um inteiro retornamos ele mesmo.
				return Integer.parseInt(expression.result);
			}
			catch(Exception e)
			{
				//Senão, tentamos capturar o valor do mesmo pelo mapa
				for(Variable variable : variables)
				{
					//Se a variável existir retorne o seu valor.
					if(variable.name.equals(expression.result))
					{
						System.out.println("Encontrou um valor!");
						return variable.value;
					}
				}
			}
			return null;
		}
		if(expression.value != null)
		{
			return solve2(expression.value,variables);
		}
		if(expression.operator != null)
		{
			leftValue = solve2(expression.left, variables);
			rightValue = solve2(expression.right, variables);
			if(leftValue == null || rightValue == null)
			{
				return null;
			}
			switch(expression.operator)
			{
				case "+":
				{
					return leftValue + rightValue;
				}
				case "-":
				{
					return leftValue - rightValue;
				}
				case "*":
				{
					return leftValue * rightValue;
				}
				case "/":
				{
					return leftValue / rightValue;
				}
				case "^":
				{
					return Math.pow(leftValue.doubleValue, rightValue.doubleValue).intValue;
				}
				default:
				{
					return leftValue;
				}
			}
		}
		else
		{
			return leftValue;	
		}
	}
	
	def dispatch compile(Expression expr)
	'''«IF expr.value != null»( «expr.value.compile» )«ENDIF»«IF expr.result != null»«expr.result»«ENDIF»«IF expr.left != null»«IF solve(expr.left) != null»«solve(expr.left)»«ELSE»«expr.left.compile»«ENDIF»«ENDIF»«IF expr.operator != null» «expr.operator» «ENDIF»«IF expr.right != null»«IF solve(expr.right) != null»«solve(expr.right)»«ELSE»«expr.right.compile»«ENDIF»«ENDIF»'''
	
		
		
//Function: type=Type id=ID '(' (param=FuncParam)? ')' block=Block ;
//FuncParam: type=Type id=ID (',' next=FuncParam)? ;
//

	def dispatch compile(Function function)
	'''«function.type.compile» «function.id» ( «IF function.param != null»«function.param.compile»«ENDIF»)
«function.block.compile»'''
	
	def dispatch compile(FuncParam funcParam)
	'''«funcParam.type.compile» «funcParam.id»«IF funcParam.next != null», «funcParam.next.compile»«ENDIF»'''
	
//Block: '{' statement=Statement '}';
//Statement: (declarations+=IDDeclaration)* (commands+=Command)*;
	def dispatch compile(Block block)
	'''
{«IF incrementCurrentScope() != null »«ENDIF»
«IF block.statement != null»«block.statement.compile»«ENDIF»
}«IF decrementCurrentScope() != null »«ENDIF»'''
	
	def Integer incrementCurrentScope() 
	{
		currentCodeScope++;
		variablesByScope.put(currentCodeScope, new ArrayList<Variable>());
		variablesByScope.get(currentCodeScope).addAll(variablesByScope.get(currentCodeScope - 1));
		return null;
	}
	
	def Integer decrementCurrentScope() 
	{
		variablesByScope.remove(currentCodeScope);
		currentCodeScope--;
		return null;
	}
	
	
	
	def dispatch compile(Statement statement)
	'''«IF statement.commands != null»«FOR command : statement.commands»	«command.compile»
«ENDFOR»«ENDIF»'''

//Command: IfCommand | WhileCommand;
//IfCommand: 'if' '(' expr=Expr ')' ifBlock = Block ('else' elseBlock=Block)?;
//WhileCommand: 'while' '(' expr=Expr ')' whileBlock=Block;
//«»
	def dispatch compile(IfCommand ifcommand)
	'''«IF solve(ifcommand.expr) == null»if ( «ifcommand.expr.compile» ) 
	«ifcommand.ifBlock.compile»«IF ifcommand.elseBlock != null»
	else 
	«ifcommand.elseBlock.compile»«
	ENDIF»«ELSE»
	«IF solve(ifcommand.expr).intValue != 0»
	«ifcommand.ifBlock.compile»«ELSE»«IF ifcommand.elseBlock != null»«ifcommand.elseBlock.compile»«ENDIF»«ENDIF»«ENDIF»'''
	
	def dispatch compile(WhileCommand whileCommand)
	'''«IF computeWhileCommand(whileCommand) == null»while ( «whileCommand.expr.compile» )
	«whileCommand.whileBlock.compile»«IF whileCommand.whileBlock != null»
	«ENDIF»
	«ELSE»
	«FOR i : 0 ..< computeWhileCommand(whileCommand)»
	«whileCommand.whileBlock.compile»
	«ENDFOR»«ENDIF»'''
	
	//Compute how many times the while command must run!
	def Integer computeWhileCommand(WhileCommand command) 
	{
		System.out.println("Entrando no computeWhileCommand!");
		//Se a resolução da expressão de condição for 0 então o while é falso
		if(solve(command.expr) == 0)
		{
			return null;
		}
		System.out.println("solve de command.expr deu != 0");
		var knownVariables = new HashSet<Variable>();
		//Garantir que as variáveis envolvidas na condição do while tem valor conhecido e só são alteradas com valores delas próprias.
		//Variáveis da condição do while
		knownVariables = computeWhileVariables(command.expr);
		System.out.println("Saindo de computeWhileVariables() para knownVariables");
		
		//Garantir valor conhecido.
		for(Variable variable : knownVariables)
		{
			//Se exitir ao menos 1 variável sem valor conhecido então é impossível determinar o valor das variáveis.
			if(variable.value == null)
				return null;
		}
		System.out.println("Garantiu variáveis conhecidas!");
		//Garantir quem interfere no valor da variável.
		//Por qeustão de simplificação se uma variável externa as da condição modificar o valor de alguma variável da condição
		//então devemos entender a condição como não alcançável
		for (Command com : command.whileBlock.statement.commands)
		{
			if(com instanceof KDeclaration)
			{
				var comRD = (com as KDeclaration).declaration;
				if(knownVariables.contains(new Variable(comRD.id.id)))
				{
					if(comRD.id != null)
					{
						var comRDVariables = computeWhileVariables(comRD.id.value);
						for(Variable variable : comRDVariables)
						{
							//Se uma variávle desconhecida modificar uma variável conhecida, então não continue!  
							if(!knownVariables.contains(variable))
							{
								return null;
							}
						}						
					}
				}
				
			}
			//TODO Adicionar suporte a possuir sub comandos sem ser expressão dentro do while.
		}
		
		//Avaliar a quantidade de vezes que o while irá rodar!
		//Para isso será utilizada a boa e velha força bruta,
		//Ou seja, vamos calcular cara paço do while (calcular cada RDesxpression dentro do while que atualize o valor de uma variável no while, com
		//isso teremos a quantidade de vezes que o while irá rodar!
		//Passo 1: Criar cópia das variáveis do while!
		var newVariableList = new ArrayList<Variable>();
		for(Variable variable : knownVariables)
		{
			System.out.println("KnownVariables: " + variable.name + "  " +variable.value);
			newVariableList.add(new Variable(variable.name, variable.value));	
		}
		//Passo 2: Calcular o valor inicial do while!
		var valorInicial = solve2(command.expr, newVariableList);
		//Passo 3: Criar contador.
		var contador = new Integer(0);
		//Passo 4: rodar o while, enquanto o valorInicial seja diferente de 0
		System.out.println("Será que chega no while²²²");
		while(valorInicial != 0)
		{
			
			System.out.println("WHILE!!!!!!");
			//Passo 5: Executar a atualização dos valores da variáveis do while!
			//Para cada comando!
			for (Command com : command.whileBlock.statement.commands)
			{
				System.out.println("Com?" + com);
				//Se o comando for uma atribuição de variável.
				if(com instanceof KDeclaration)
				{
					System.out.println("Instanceof?" + com);
					var comRD = (com as KDeclaration).declaration;
					//Se for para uma variável conhecida
					System.out.println("com.id.id?" + comRD.id.id);
					if(knownVariables.contains(new Variable(comRD.id.id)))
					{
						System.out.println("Contains?" + com);
						var currentVariable = new Variable("");
						for(Variable variable : newVariableList)
						{
							System.out.println("Variable: " + variable.name + " " + variable.value);
							if(variable.name == comRD.id.id)
							{
								currentVariable = variable;
							}
						}
						currentVariable.value = solve2(comRD.id.value, newVariableList);
					}
				}
			}
			//Passo 6: incrementa contador
			contador++;
			//Passo 7: Atualiza valor de referência
			valorInicial = solve2(command.expr, newVariableList);
		}
		return contador;
	}
	
	def HashSet<Variable> computeWhileVariables(Expression expression) 
	{
		System.out.println("Entrando em computeWhileVariables()");
		var variables = new HashSet<Variable>();
		if(expression == null)
		{
			return null;
		}
		if(expression.result != null)
		{
			try
			{
				//Se for um inteiro BOOM!!!.
				Integer.parseInt(expression.result);
				return null;
			}
			catch(Exception e)
			{
				//Senão, capturamos a variável
				for(Variable variable : variablesByScope.get(currentCodeScope))
				{
					//Se a variável existir retorne-a.
					if(variable.name.equals(expression.result))
					{
						variables.add(variable);
						return variables;
					}
				}
			}
			return null;
		}
		if(expression.value != null)
		{
			var temp = computeWhileVariables(expression.value);
			if(temp != null)
			{
				variables.addAll(temp);
			}
		}
		if(expression.left != null)
		{
			var leftValue = computeWhileVariables(expression.left);
			if(leftValue != null)
			{
				variables.addAll(leftValue);
			}
		}
		if(expression.right != null)
		{
			var something = computeWhileVariables(expression.right);
			if(something != null)
			{
				variables.addAll(something);
			}
		}
		if(variables.size == 0)
		{
			variables = null;
		}
		return variables;
	}
	
	def dispatch compile(Type type)
	'''«type.value»'''
	
	override void doGenerate(Resource resource, IFileSystemAccess fsa) {
		currentCodeScope = 0;
		variablesByScope = new HashMap<Integer, List<Variable>>();
		for(e: resource.allContents.toIterable.filter(Code)) 
		{ 
			fsa.generateFile(resource.normalizedURI.lastSegment+"_partial", e.compileCode);
		}
	}
}
