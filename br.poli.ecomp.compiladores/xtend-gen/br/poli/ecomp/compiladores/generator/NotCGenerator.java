/**
 * generated by Xtext
 */
package br.poli.ecomp.compiladores.generator;

import br.poli.ecomp.compiladores.notC.Block;
import br.poli.ecomp.compiladores.notC.Code;
import br.poli.ecomp.compiladores.notC.Command;
import br.poli.ecomp.compiladores.notC.Declaration;
import br.poli.ecomp.compiladores.notC.Expression;
import br.poli.ecomp.compiladores.notC.FuncParam;
import br.poli.ecomp.compiladores.notC.Function;
import br.poli.ecomp.compiladores.notC.IDDeclaration;
import br.poli.ecomp.compiladores.notC.IfCommand;
import br.poli.ecomp.compiladores.notC.RDeclaration;
import br.poli.ecomp.compiladores.notC.Statement;
import br.poli.ecomp.compiladores.notC.Type;
import br.poli.ecomp.compiladores.notC.WhileCommand;
import com.google.common.base.Objects;
import com.google.common.collect.Iterables;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.common.util.TreeIterator;
import org.eclipse.emf.common.util.URI;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.generator.IFileSystemAccess;
import org.eclipse.xtext.generator.IGenerator;
import org.eclipse.xtext.xbase.lib.Exceptions;
import org.eclipse.xtext.xbase.lib.IteratorExtensions;

/**
 * Generates code from your model files on save.
 * 
 * see http://www.eclipse.org/Xtext/documentation.html#TutorialCodeGeneration
 */
@SuppressWarnings("all")
public class NotCGenerator implements IGenerator {
  public static class Variable {
    public String name;
    
    public Integer value = null;
    
    public Variable(final String n) {
      this.name = n;
    }
    
    public Variable(final String n, final Integer i) {
      this.name = n;
      this.value = i;
    }
  }
  
  private Integer currentCodeScope;
  
  private Map<Integer, List<NotCGenerator.Variable>> variablesByScope;
  
  public CharSequence compileCode(final Code code) {
    StringConcatenation _builder = new StringConcatenation();
    {
      ArrayList<NotCGenerator.Variable> _arrayList = new ArrayList<NotCGenerator.Variable>();
      List<NotCGenerator.Variable> _put = this.variablesByScope.put(this.currentCodeScope, _arrayList);
      boolean _equals = Objects.equal(_put, null);
      if (_equals) {
      }
    }
    {
      EList<Declaration> _declarations = code.getDeclarations();
      boolean _notEquals = (!Objects.equal(_declarations, null));
      if (_notEquals) {
        {
          EList<Declaration> _declarations_1 = code.getDeclarations();
          for(final Declaration declaration : _declarations_1) {
            CharSequence _compile = this.compile(declaration);
            _builder.append(_compile, "");
            _builder.newLineIfNotEmpty();
          }
        }
      }
    }
    {
      EList<Function> _functions = code.getFunctions();
      boolean _notEquals_1 = (!Objects.equal(_functions, null));
      if (_notEquals_1) {
        {
          EList<Function> _functions_1 = code.getFunctions();
          for(final Function function : _functions_1) {
            CharSequence _compile_1 = this.compile(function);
            _builder.append(_compile_1, "");
          }
        }
      }
    }
    _builder.newLineIfNotEmpty();
    return _builder;
  }
  
  protected CharSequence _compile(final Declaration declaration) {
    StringConcatenation _builder = new StringConcatenation();
    Type _type = declaration.getType();
    Object _compile = this.compile(_type);
    _builder.append(_compile, "");
    _builder.append(" ");
    RDeclaration _value = declaration.getValue();
    Object _compile_1 = this.compile(_value);
    _builder.append(_compile_1, "");
    _builder.append(";");
    return _builder;
  }
  
  protected CharSequence _compile(final RDeclaration rDeclaration) {
    StringConcatenation _builder = new StringConcatenation();
    {
      IDDeclaration _id = rDeclaration.getId();
      boolean _notEquals = (!Objects.equal(_id, null));
      if (_notEquals) {
        IDDeclaration _id_1 = rDeclaration.getId();
        Object _compile = this.compile(_id_1);
        _builder.append(_compile, "");
      }
    }
    {
      RDeclaration _left = rDeclaration.getLeft();
      boolean _notEquals_1 = (!Objects.equal(_left, null));
      if (_notEquals_1) {
        RDeclaration _left_1 = rDeclaration.getLeft();
        Object _compile_1 = this.compile(_left_1);
        _builder.append(_compile_1, "");
      }
    }
    {
      RDeclaration _next = rDeclaration.getNext();
      boolean _notEquals_2 = (!Objects.equal(_next, null));
      if (_notEquals_2) {
        _builder.append(", ");
        RDeclaration _next_1 = rDeclaration.getNext();
        Object _compile_2 = this.compile(_next_1);
        _builder.append(_compile_2, "");
      }
    }
    return _builder;
  }
  
  protected CharSequence _compile(final IDDeclaration idDeclaration) {
    StringConcatenation _builder = new StringConcatenation();
    {
      List<NotCGenerator.Variable> _get = this.variablesByScope.get(this.currentCodeScope);
      String _id = idDeclaration.getId();
      String _string = _id.toString();
      Expression _value = idDeclaration.getValue();
      Integer _solve = this.solve(_value);
      NotCGenerator.Variable _variable = new NotCGenerator.Variable(_string, _solve);
      boolean _add = _get.add(_variable);
      if (_add) {
      }
    }
    String _id_1 = idDeclaration.getId();
    _builder.append(_id_1, "");
    {
      Expression _value_1 = idDeclaration.getValue();
      boolean _notEquals = (!Objects.equal(_value_1, null));
      if (_notEquals) {
        _builder.append(" = ");
        Expression _value_2 = idDeclaration.getValue();
        Object _compile = this.compile(_value_2);
        _builder.append(_compile, "");
      }
    }
    return _builder;
  }
  
  private Integer leftValue;
  
  private Integer rightValue;
  
  public Integer solve(final Expression expression) {
    boolean _equals = Objects.equal(expression, null);
    if (_equals) {
      return null;
    }
    String _result = expression.getResult();
    boolean _notEquals = (!Objects.equal(_result, null));
    if (_notEquals) {
      try {
        String _result_1 = expression.getResult();
        return Integer.valueOf(Integer.parseInt(_result_1));
      } catch (final Throwable _t) {
        if (_t instanceof Exception) {
          final Exception e = (Exception)_t;
          List<NotCGenerator.Variable> _get = this.variablesByScope.get(this.currentCodeScope);
          for (final NotCGenerator.Variable variable : _get) {
            String _result_2 = expression.getResult();
            boolean _equals_1 = variable.name.equals(_result_2);
            if (_equals_1) {
              return variable.value;
            }
          }
        } else {
          throw Exceptions.sneakyThrow(_t);
        }
      }
      return null;
    }
    Expression _value = expression.getValue();
    boolean _notEquals_1 = (!Objects.equal(_value, null));
    if (_notEquals_1) {
      Expression _value_1 = expression.getValue();
      return this.solve(_value_1);
    }
    String _operator = expression.getOperator();
    boolean _notEquals_2 = (!Objects.equal(_operator, null));
    if (_notEquals_2) {
      Expression _left = expression.getLeft();
      Integer _solve = this.solve(_left);
      this.leftValue = _solve;
      Expression _right = expression.getRight();
      Integer _solve_1 = this.solve(_right);
      this.rightValue = _solve_1;
      boolean _or = false;
      boolean _equals_2 = Objects.equal(this.leftValue, null);
      if (_equals_2) {
        _or = true;
      } else {
        boolean _equals_3 = Objects.equal(this.rightValue, null);
        _or = _equals_3;
      }
      if (_or) {
        return null;
      }
      String _operator_1 = expression.getOperator();
      boolean _matched = false;
      if (!_matched) {
        if (Objects.equal(_operator_1, "+")) {
          _matched=true;
          return Integer.valueOf(((this.leftValue).intValue() + (this.rightValue).intValue()));
        }
      }
      if (!_matched) {
        if (Objects.equal(_operator_1, "-")) {
          _matched=true;
          return Integer.valueOf(((this.leftValue).intValue() - (this.rightValue).intValue()));
        }
      }
      if (!_matched) {
        if (Objects.equal(_operator_1, "*")) {
          _matched=true;
          return Integer.valueOf(((this.leftValue).intValue() * (this.rightValue).intValue()));
        }
      }
      if (!_matched) {
        if (Objects.equal(_operator_1, "/")) {
          _matched=true;
          return Integer.valueOf(((this.leftValue).intValue() / (this.rightValue).intValue()));
        }
      }
      if (!_matched) {
        if (Objects.equal(_operator_1, "^")) {
          _matched=true;
          double _doubleValue = this.leftValue.doubleValue();
          double _doubleValue_1 = this.rightValue.doubleValue();
          double _pow = Math.pow(_doubleValue, _doubleValue_1);
          return Integer.valueOf(Double.valueOf(_pow).intValue());
        }
      }
      return this.leftValue;
    } else {
      return this.leftValue;
    }
  }
  
  protected CharSequence _compile(final Expression expr) {
    StringConcatenation _builder = new StringConcatenation();
    {
      Expression _value = expr.getValue();
      boolean _notEquals = (!Objects.equal(_value, null));
      if (_notEquals) {
        _builder.append("( ");
        Expression _value_1 = expr.getValue();
        Object _compile = this.compile(_value_1);
        _builder.append(_compile, "");
        _builder.append(" )");
      }
    }
    {
      Expression _left = expr.getLeft();
      boolean _notEquals_1 = (!Objects.equal(_left, null));
      if (_notEquals_1) {
        Expression _left_1 = expr.getLeft();
        Object _compile_1 = this.compile(_left_1);
        _builder.append(_compile_1, "");
      }
    }
    {
      String _operator = expr.getOperator();
      boolean _notEquals_2 = (!Objects.equal(_operator, null));
      if (_notEquals_2) {
        _builder.append(" ");
        String _operator_1 = expr.getOperator();
        _builder.append(_operator_1, "");
        _builder.append(" ");
      }
    }
    {
      Expression _right = expr.getRight();
      boolean _notEquals_3 = (!Objects.equal(_right, null));
      if (_notEquals_3) {
        Expression _right_1 = expr.getRight();
        Object _compile_2 = this.compile(_right_1);
        _builder.append(_compile_2, "");
      }
    }
    return _builder;
  }
  
  protected CharSequence _compile(final Function function) {
    StringConcatenation _builder = new StringConcatenation();
    Type _type = function.getType();
    Object _compile = this.compile(_type);
    _builder.append(_compile, "");
    _builder.append(" ");
    String _id = function.getId();
    _builder.append(_id, "");
    _builder.append(" ( ");
    {
      FuncParam _param = function.getParam();
      boolean _notEquals = (!Objects.equal(_param, null));
      if (_notEquals) {
        FuncParam _param_1 = function.getParam();
        Object _compile_1 = this.compile(_param_1);
        _builder.append(_compile_1, "");
      }
    }
    _builder.append(")");
    _builder.newLineIfNotEmpty();
    Block _block = function.getBlock();
    Object _compile_2 = this.compile(_block);
    _builder.append(_compile_2, "");
    return _builder;
  }
  
  protected CharSequence _compile(final FuncParam funcParam) {
    StringConcatenation _builder = new StringConcatenation();
    Type _type = funcParam.getType();
    Object _compile = this.compile(_type);
    _builder.append(_compile, "");
    _builder.append(" ");
    String _id = funcParam.getId();
    _builder.append(_id, "");
    {
      FuncParam _next = funcParam.getNext();
      boolean _notEquals = (!Objects.equal(_next, null));
      if (_notEquals) {
        _builder.append(", ");
        FuncParam _next_1 = funcParam.getNext();
        Object _compile_1 = this.compile(_next_1);
        _builder.append(_compile_1, "");
      }
    }
    return _builder;
  }
  
  protected CharSequence _compile(final Block block) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("{");
    _builder.newLine();
    {
      Statement _statement = block.getStatement();
      boolean _notEquals = (!Objects.equal(_statement, null));
      if (_notEquals) {
        Statement _statement_1 = block.getStatement();
        Object _compile = this.compile(_statement_1);
        _builder.append(_compile, "");
      }
    }
    _builder.newLineIfNotEmpty();
    _builder.append("}");
    return _builder;
  }
  
  protected CharSequence _compile(final Statement statement) {
    StringConcatenation _builder = new StringConcatenation();
    {
      EList<Declaration> _declarations = statement.getDeclarations();
      boolean _notEquals = (!Objects.equal(_declarations, null));
      if (_notEquals) {
        {
          EList<Declaration> _declarations_1 = statement.getDeclarations();
          for(final Declaration declaration : _declarations_1) {
            _builder.append("\t");
            Object _compile = this.compile(declaration);
            _builder.append(_compile, "");
            _builder.newLineIfNotEmpty();
          }
        }
      }
    }
    {
      EList<Command> _commands = statement.getCommands();
      boolean _notEquals_1 = (!Objects.equal(_commands, null));
      if (_notEquals_1) {
        {
          EList<Command> _commands_1 = statement.getCommands();
          for(final Command command : _commands_1) {
            _builder.append("\t");
            Object _compile_1 = this.compile(command);
            _builder.append(_compile_1, "");
            _builder.newLineIfNotEmpty();
          }
        }
      }
    }
    return _builder;
  }
  
  protected CharSequence _compile(final IfCommand ifcommand) {
    StringConcatenation _builder = new StringConcatenation();
    {
      Expression _expr = ifcommand.getExpr();
      Integer _solve = this.solve(_expr);
      boolean _equals = Objects.equal(_solve, null);
      if (_equals) {
        _builder.append("if ( ");
        Expression _expr_1 = ifcommand.getExpr();
        Object _compile = this.compile(_expr_1);
        _builder.append(_compile, "");
        _builder.append(" ) ");
        _builder.newLineIfNotEmpty();
        _builder.append("\t");
        Block _ifBlock = ifcommand.getIfBlock();
        Object _compile_1 = this.compile(_ifBlock);
        _builder.append(_compile_1, "\t");
        {
          Block _elseBlock = ifcommand.getElseBlock();
          boolean _notEquals = (!Objects.equal(_elseBlock, null));
          if (_notEquals) {
            _builder.newLineIfNotEmpty();
            _builder.append("\t");
            _builder.append("else ");
            _builder.newLine();
            _builder.append("\t");
            Block _elseBlock_1 = ifcommand.getElseBlock();
            Object _compile_2 = this.compile(_elseBlock_1);
            _builder.append(_compile_2, "\t");
          }
        }
        _builder.newLineIfNotEmpty();
        _builder.append("\t");
      } else {
        {
          Expression _expr_2 = ifcommand.getExpr();
          Integer _solve_1 = this.solve(_expr_2);
          int _intValue = _solve_1.intValue();
          boolean _notEquals_1 = (_intValue != 0);
          if (_notEquals_1) {
            Block _ifBlock_1 = ifcommand.getIfBlock();
            Object _compile_3 = this.compile(_ifBlock_1);
            _builder.append(_compile_3, "");
          } else {
            {
              Block _elseBlock_2 = ifcommand.getElseBlock();
              boolean _notEquals_2 = (!Objects.equal(_elseBlock_2, null));
              if (_notEquals_2) {
                Block _elseBlock_3 = ifcommand.getElseBlock();
                Object _compile_4 = this.compile(_elseBlock_3);
                _builder.append(_compile_4, "");
              }
            }
          }
        }
      }
    }
    return _builder;
  }
  
  protected CharSequence _compile(final WhileCommand whileCommand) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("while ( ");
    Expression _expr = whileCommand.getExpr();
    Object _compile = this.compile(_expr);
    _builder.append(_compile, "");
    _builder.append(" )");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    Block _whileBlock = whileCommand.getWhileBlock();
    Object _compile_1 = this.compile(_whileBlock);
    _builder.append(_compile_1, "\t");
    {
      Block _whileBlock_1 = whileCommand.getWhileBlock();
      boolean _notEquals = (!Objects.equal(_whileBlock_1, null));
      if (_notEquals) {
      }
    }
    return _builder;
  }
  
  protected CharSequence _compile(final Type type) {
    StringConcatenation _builder = new StringConcatenation();
    String _value = type.getValue();
    _builder.append(_value, "");
    return _builder;
  }
  
  public void doGenerate(final Resource resource, final IFileSystemAccess fsa) {
    this.currentCodeScope = Integer.valueOf(0);
    HashMap<Integer, List<NotCGenerator.Variable>> _hashMap = new HashMap<Integer, List<NotCGenerator.Variable>>();
    this.variablesByScope = _hashMap;
    TreeIterator<EObject> _allContents = resource.getAllContents();
    Iterable<EObject> _iterable = IteratorExtensions.<EObject>toIterable(_allContents);
    Iterable<Code> _filter = Iterables.<Code>filter(_iterable, Code.class);
    for (final Code e : _filter) {
      URI _normalizedURI = EcoreUtil2.getNormalizedURI(resource);
      String _lastSegment = _normalizedURI.lastSegment();
      String _plus = (_lastSegment + "_");
      CharSequence _compileCode = this.compileCode(e);
      fsa.generateFile(_plus, _compileCode);
    }
  }
  
  public CharSequence compile(final EObject ifcommand) {
    if (ifcommand instanceof IfCommand) {
      return _compile((IfCommand)ifcommand);
    } else if (ifcommand instanceof WhileCommand) {
      return _compile((WhileCommand)ifcommand);
    } else if (ifcommand instanceof Block) {
      return _compile((Block)ifcommand);
    } else if (ifcommand instanceof Declaration) {
      return _compile((Declaration)ifcommand);
    } else if (ifcommand instanceof Expression) {
      return _compile((Expression)ifcommand);
    } else if (ifcommand instanceof FuncParam) {
      return _compile((FuncParam)ifcommand);
    } else if (ifcommand instanceof Function) {
      return _compile((Function)ifcommand);
    } else if (ifcommand instanceof IDDeclaration) {
      return _compile((IDDeclaration)ifcommand);
    } else if (ifcommand instanceof RDeclaration) {
      return _compile((RDeclaration)ifcommand);
    } else if (ifcommand instanceof Statement) {
      return _compile((Statement)ifcommand);
    } else if (ifcommand instanceof Type) {
      return _compile((Type)ifcommand);
    } else {
      throw new IllegalArgumentException("Unhandled parameter types: " +
        Arrays.<Object>asList(ifcommand).toString());
    }
  }
}
